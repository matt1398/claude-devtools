import React from 'react';

// =============================================================================
// Syntax Highlighting (Basic Token-based)
// =============================================================================

// Basic keyword sets for common languages
const KEYWORDS: Record<string, Set<string>> = {
  typescript: new Set([
    'import',
    'export',
    'from',
    'const',
    'let',
    'var',
    'function',
    'class',
    'interface',
    'type',
    'enum',
    'return',
    'if',
    'else',
    'for',
    'while',
    'do',
    'switch',
    'case',
    'break',
    'continue',
    'try',
    'catch',
    'finally',
    'throw',
    'new',
    'this',
    'super',
    'extends',
    'implements',
    'async',
    'await',
    'public',
    'private',
    'protected',
    'static',
    'readonly',
    'abstract',
    'as',
    'typeof',
    'instanceof',
    'in',
    'of',
    'keyof',
    'void',
    'never',
    'unknown',
    'any',
    'null',
    'undefined',
    'true',
    'false',
    'default',
  ]),
  javascript: new Set([
    'import',
    'export',
    'from',
    'const',
    'let',
    'var',
    'function',
    'class',
    'return',
    'if',
    'else',
    'for',
    'while',
    'do',
    'switch',
    'case',
    'break',
    'continue',
    'try',
    'catch',
    'finally',
    'throw',
    'new',
    'this',
    'super',
    'extends',
    'async',
    'await',
    'typeof',
    'instanceof',
    'in',
    'of',
    'void',
    'null',
    'undefined',
    'true',
    'false',
    'default',
  ]),
  python: new Set([
    'import',
    'from',
    'as',
    'def',
    'class',
    'return',
    'if',
    'elif',
    'else',
    'for',
    'while',
    'break',
    'continue',
    'try',
    'except',
    'finally',
    'raise',
    'with',
    'as',
    'pass',
    'lambda',
    'yield',
    'global',
    'nonlocal',
    'assert',
    'and',
    'or',
    'not',
    'in',
    'is',
    'True',
    'False',
    'None',
    'async',
    'await',
    'self',
    'cls',
  ]),
  rust: new Set([
    'fn',
    'let',
    'mut',
    'const',
    'static',
    'struct',
    'enum',
    'impl',
    'trait',
    'pub',
    'mod',
    'use',
    'crate',
    'self',
    'super',
    'where',
    'for',
    'loop',
    'while',
    'if',
    'else',
    'match',
    'return',
    'break',
    'continue',
    'move',
    'ref',
    'as',
    'in',
    'unsafe',
    'async',
    'await',
    'dyn',
    'true',
    'false',
    'type',
    'extern',
  ]),
  go: new Set([
    'package',
    'import',
    'func',
    'var',
    'const',
    'type',
    'struct',
    'interface',
    'map',
    'chan',
    'go',
    'defer',
    'return',
    'if',
    'else',
    'for',
    'range',
    'switch',
    'case',
    'default',
    'break',
    'continue',
    'fallthrough',
    'select',
    'nil',
    'true',
    'false',
  ]),
  r: new Set([
    'if',
    'else',
    'for',
    'while',
    'repeat',
    'function',
    'return',
    'next',
    'break',
    'in',
    'library',
    'require',
    'source',
    'TRUE',
    'FALSE',
    'NULL',
    'NA',
    'Inf',
    'NaN',
    'NA_integer_',
    'NA_real_',
    'NA_complex_',
    'NA_character_',
  ]),
  ruby: new Set([
    'def',
    'class',
    'module',
    'end',
    'do',
    'if',
    'elsif',
    'else',
    'unless',
    'while',
    'until',
    'for',
    'in',
    'begin',
    'rescue',
    'ensure',
    'raise',
    'return',
    'yield',
    'block_given?',
    'require',
    'require_relative',
    'include',
    'extend',
    'attr_accessor',
    'attr_reader',
    'attr_writer',
    'self',
    'super',
    'nil',
    'true',
    'false',
    'and',
    'or',
    'not',
    'then',
    'when',
    'case',
    'lambda',
    'proc',
    'puts',
    'print',
  ]),
  php: new Set([
    'function',
    'class',
    'interface',
    'trait',
    'extends',
    'implements',
    'namespace',
    'use',
    'public',
    'private',
    'protected',
    'static',
    'abstract',
    'final',
    'const',
    'var',
    'new',
    'return',
    'if',
    'elseif',
    'else',
    'for',
    'foreach',
    'while',
    'do',
    'switch',
    'case',
    'break',
    'continue',
    'default',
    'try',
    'catch',
    'finally',
    'throw',
    'as',
    'echo',
    'print',
    'require',
    'require_once',
    'include',
    'include_once',
    'true',
    'false',
    'null',
    'array',
    'isset',
    'unset',
    'empty',
    'self',
    'this',
  ]),
  sql: new Set([
    'SELECT',
    'FROM',
    'WHERE',
    'INSERT',
    'INTO',
    'UPDATE',
    'SET',
    'DELETE',
    'CREATE',
    'ALTER',
    'DROP',
    'TABLE',
    'INDEX',
    'VIEW',
    'DATABASE',
    'JOIN',
    'INNER',
    'LEFT',
    'RIGHT',
    'OUTER',
    'FULL',
    'CROSS',
    'ON',
    'AND',
    'OR',
    'NOT',
    'IN',
    'EXISTS',
    'BETWEEN',
    'LIKE',
    'IS',
    'NULL',
    'AS',
    'ORDER',
    'BY',
    'GROUP',
    'HAVING',
    'LIMIT',
    'OFFSET',
    'UNION',
    'ALL',
    'DISTINCT',
    'COUNT',
    'SUM',
    'AVG',
    'MIN',
    'MAX',
    'CASE',
    'WHEN',
    'THEN',
    'ELSE',
    'END',
    'BEGIN',
    'COMMIT',
    'ROLLBACK',
    'TRANSACTION',
    'PRIMARY',
    'KEY',
    'FOREIGN',
    'REFERENCES',
    'CONSTRAINT',
    'DEFAULT',
    'VALUES',
    'TRUE',
    'FALSE',
    'INTEGER',
    'VARCHAR',
    'TEXT',
    'BOOLEAN',
    'DATE',
    'TIMESTAMP',
  ]),
  bash: new Set([
    'if',
    'then',
    'else',
    'elif',
    'fi',
    'for',
    'while',
    'do',
    'done',
    'case',
    'esac',
    'in',
    'function',
    'return',
    'local',
    'export',
    'readonly',
    'declare',
    'typeset',
    'unset',
    'shift',
    'source',
    'eval',
    'exec',
    'exit',
    'trap',
    'break',
    'continue',
    'echo',
    'printf',
    'read',
    'test',
    'true',
    'false',
    'cd',
    'pwd',
    'mkdir',
    'rm',
    'cp',
    'mv',
    'ls',
    'cat',
    'grep',
    'sed',
    'awk',
    'find',
    'sort',
    'uniq',
    'wc',
    'head',
    'tail',
    'chmod',
    'chown',
    'sudo',
    'apt',
    'pip',
    'npm',
    'pnpm',
    'yarn',
    'git',
    'docker',
    'curl',
    'wget',
  ]),
  c: new Set([
    'auto',
    'break',
    'case',
    'char',
    'const',
    'continue',
    'default',
    'do',
    'double',
    'else',
    'enum',
    'extern',
    'float',
    'for',
    'goto',
    'if',
    'inline',
    'int',
    'long',
    'register',
    'return',
    'short',
    'signed',
    'sizeof',
    'static',
    'struct',
    'switch',
    'typedef',
    'union',
    'unsigned',
    'void',
    'volatile',
    'while',
    'NULL',
    'true',
    'false',
    'include',
    'define',
    'ifdef',
    'ifndef',
    'endif',
    'pragma',
  ]),
  java: new Set([
    'abstract',
    'assert',
    'boolean',
    'break',
    'byte',
    'case',
    'catch',
    'char',
    'class',
    'const',
    'continue',
    'default',
    'do',
    'double',
    'else',
    'enum',
    'extends',
    'final',
    'finally',
    'float',
    'for',
    'if',
    'implements',
    'import',
    'instanceof',
    'int',
    'interface',
    'long',
    'native',
    'new',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'short',
    'static',
    'strictfp',
    'super',
    'switch',
    'synchronized',
    'this',
    'throw',
    'throws',
    'transient',
    'try',
    'void',
    'volatile',
    'while',
    'true',
    'false',
    'null',
    'var',
    'yield',
    'record',
    'sealed',
    'permits',
  ]),
  kotlin: new Set([
    'abstract',
    'annotation',
    'as',
    'break',
    'by',
    'catch',
    'class',
    'companion',
    'const',
    'constructor',
    'continue',
    'crossinline',
    'data',
    'do',
    'else',
    'enum',
    'external',
    'false',
    'final',
    'finally',
    'for',
    'fun',
    'if',
    'import',
    'in',
    'infix',
    'init',
    'inline',
    'inner',
    'interface',
    'internal',
    'is',
    'lateinit',
    'noinline',
    'null',
    'object',
    'open',
    'operator',
    'out',
    'override',
    'package',
    'private',
    'protected',
    'public',
    'reified',
    'return',
    'sealed',
    'super',
    'suspend',
    'this',
    'throw',
    'true',
    'try',
    'typealias',
    'val',
    'var',
    'vararg',
    'when',
    'where',
    'while',
  ]),
  swift: new Set([
    'associatedtype',
    'break',
    'case',
    'catch',
    'class',
    'continue',
    'default',
    'defer',
    'deinit',
    'do',
    'else',
    'enum',
    'extension',
    'fallthrough',
    'false',
    'fileprivate',
    'for',
    'func',
    'guard',
    'if',
    'import',
    'in',
    'init',
    'inout',
    'internal',
    'is',
    'let',
    'nil',
    'open',
    'operator',
    'override',
    'private',
    'protocol',
    'public',
    'repeat',
    'rethrows',
    'return',
    'self',
    'static',
    'struct',
    'subscript',
    'super',
    'switch',
    'throw',
    'throws',
    'true',
    'try',
    'typealias',
    'var',
    'where',
    'while',
    'async',
    'await',
  ]),
  lua: new Set([
    'and',
    'break',
    'do',
    'else',
    'elseif',
    'end',
    'false',
    'for',
    'function',
    'goto',
    'if',
    'in',
    'local',
    'nil',
    'not',
    'or',
    'repeat',
    'return',
    'then',
    'true',
    'until',
    'while',
    'self',
    'require',
    'print',
    'type',
    'tostring',
    'tonumber',
    'pairs',
    'ipairs',
    'error',
    'pcall',
    'xpcall',
    'setmetatable',
    'getmetatable',
  ]),
  html: new Set([
    'div',
    'span',
    'html',
    'head',
    'body',
    'title',
    'meta',
    'link',
    'script',
    'style',
    'section',
    'article',
    'header',
    'footer',
    'nav',
    'main',
    'aside',
    'form',
    'input',
    'button',
    'select',
    'option',
    'textarea',
    'label',
    'table',
    'thead',
    'tbody',
    'tr',
    'th',
    'td',
    'ul',
    'ol',
    'li',
    'a',
    'p',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'img',
    'video',
    'audio',
    'canvas',
    'svg',
    'class',
    'id',
    'src',
    'href',
    'type',
    'name',
    'value',
    'placeholder',
    'alt',
    'width',
    'height',
    'true',
    'false',
  ]),
  yaml: new Set([
    'true',
    'false',
    'null',
    'yes',
    'no',
    'on',
    'off',
  ]),
};

// Extend tsx/jsx to use typescript/javascript keywords
KEYWORDS.tsx = KEYWORDS.typescript;
KEYWORDS.jsx = KEYWORDS.javascript;

// Extend zsh/fish to use bash keywords
KEYWORDS.zsh = KEYWORDS.bash;
KEYWORDS.fish = KEYWORDS.bash;

// Extend cpp/hpp to use c keywords (superset)
KEYWORDS.cpp = new Set([...KEYWORDS.c, ...[
  'class',
  'namespace',
  'template',
  'typename',
  'public',
  'private',
  'protected',
  'virtual',
  'override',
  'final',
  'new',
  'delete',
  'try',
  'catch',
  'throw',
  'noexcept',
  'constexpr',
  'decltype',
  'nullptr',
  'this',
  'using',
  'friend',
  'operator',
  'dynamic_cast',
  'static_cast',
  'reinterpret_cast',
  'const_cast',
  'bool',
  'wchar_t',
  'auto',
]]);
KEYWORDS.hpp = KEYWORDS.cpp;

/**
 * Very basic tokenization for syntax highlighting.
 * This is a simple approach without a full parser.
 */
export function highlightLine(line: string, language: string): React.ReactNode[] {
  const keywords = KEYWORDS[language] || new Set();

  // If no highlighting support, return plain text as single-element array
  if (keywords.size === 0 && !['json', 'css', 'bash'].includes(language)) {
    return [line];
  }

  const segments: React.ReactNode[] = [];
  let currentPos = 0;
  const lineLength = line.length;

  while (currentPos < lineLength) {
    const remaining = line.slice(currentPos);

    // Check for string (double quote)
    if (remaining.startsWith('"')) {
      const endQuote = remaining.indexOf('"', 1);
      if (endQuote !== -1) {
        const str = remaining.slice(0, endQuote + 1);
        segments.push(
          React.createElement(
            'span',
            { key: currentPos, style: { color: 'var(--syntax-string)' } },
            str
          )
        );
        currentPos += str.length;
        continue;
      }
    }

    // Check for string (single quote)
    if (remaining.startsWith("'")) {
      const endQuote = remaining.indexOf("'", 1);
      if (endQuote !== -1) {
        const str = remaining.slice(0, endQuote + 1);
        segments.push(
          React.createElement(
            'span',
            { key: currentPos, style: { color: 'var(--syntax-string)' } },
            str
          )
        );
        currentPos += str.length;
        continue;
      }
    }

    // Check for template literal (backtick)
    if (remaining.startsWith('`')) {
      const endQuote = remaining.indexOf('`', 1);
      if (endQuote !== -1) {
        const str = remaining.slice(0, endQuote + 1);
        segments.push(
          React.createElement(
            'span',
            { key: currentPos, style: { color: 'var(--syntax-string)' } },
            str
          )
        );
        currentPos += str.length;
        continue;
      }
    }

    // Check for comment (// style)
    if (remaining.startsWith('//')) {
      segments.push(
        React.createElement(
          'span',
          { key: currentPos, style: { color: 'var(--syntax-comment)', fontStyle: 'italic' } },
          remaining
        )
      );
      break;
    }

    // Check for comment (# style for Python/Shell/R/Ruby/PHP/YAML)
    if (
      (language === 'python' || language === 'bash' || language === 'zsh' || language === 'fish' ||
        language === 'r' || language === 'ruby' || language === 'php' || language === 'yaml') &&
      remaining.startsWith('#')
    ) {
      segments.push(
        React.createElement(
          'span',
          { key: currentPos, style: { color: 'var(--syntax-comment)', fontStyle: 'italic' } },
          remaining
        )
      );
      break;
    }

    // Check for comment (-- style for SQL/Lua)
    if ((language === 'sql' || language === 'lua') && remaining.startsWith('--')) {
      segments.push(
        React.createElement(
          'span',
          { key: currentPos, style: { color: 'var(--syntax-comment)', fontStyle: 'italic' } },
          remaining
        )
      );
      break;
    }

    // Check for numbers
    const numberMatch = /^(\d+\.?\d*)/.exec(remaining);
    if (numberMatch && (currentPos === 0 || /\W/.test(line[currentPos - 1]))) {
      segments.push(
        React.createElement(
          'span',
          { key: currentPos, style: { color: 'var(--syntax-number)' } },
          numberMatch[1]
        )
      );
      currentPos += numberMatch[1].length;
      continue;
    }

    // Check for keywords and identifiers
    const wordMatch = /^([a-zA-Z_$][a-zA-Z0-9_$]*)/.exec(remaining);
    if (wordMatch) {
      const word = wordMatch[1];
      // SQL keywords are case-insensitive
      if (keywords.has(word) || (language === 'sql' && keywords.has(word.toUpperCase()))) {
        segments.push(
          React.createElement(
            'span',
            { key: currentPos, style: { color: 'var(--syntax-keyword)', fontWeight: 500 } },
            word
          )
        );
      } else if ((word[0]?.toUpperCase() ?? '') === word[0] && word.length > 1) {
        // Likely a type/class name
        segments.push(
          React.createElement(
            'span',
            { key: currentPos, style: { color: 'var(--syntax-type)' } },
            word
          )
        );
      } else {
        segments.push(word);
      }
      currentPos += word.length;
      continue;
    }

    // Check for operators and punctuation
    const opMatch = /^([=<>!+\-*/%&|^~?:;,.{}()[\]])/.exec(remaining);
    if (opMatch) {
      segments.push(
        React.createElement(
          'span',
          { key: currentPos, style: { color: 'var(--syntax-operator)' } },
          opMatch[1]
        )
      );
      currentPos += 1;
      continue;
    }

    // Default: just add the character
    segments.push(remaining[0]);
    currentPos += 1;
  }

  return segments;
}
